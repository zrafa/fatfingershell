/*  Copyright 1992, 1993 John Bovey, University of Kent at Canterbury.
 *
 *  Redistribution and use in source code and/or executable forms, with
 *  or without modification, are permitted provided that the following
 *  condition is met:
 *
 *  Any redistribution must retain the above copyright notice, this
 *  condition and the following disclaimer, either as part of the
 *  program source code included in the redistribution or in human-
 *  readable materials provided with the redistribution.
 *
 *  THIS SOFTWARE IS PROVIDED "AS IS".  Any express or implied
 *  warranties concerning this software are disclaimed by the copyright
 *  holder to the fullest extent permitted by applicable law.  In no
 *  event shall the copyright-holder be liable for any damages of any
 *  kind, however caused and on any theory of liability, arising in any
 *  way out of the use of, or inability to use, this software.
 *
 *  -------------------------------------------------------------------
 *
 *  In other words, do not misrepresent my work as your own work, and
 *  do not sue me if it causes problems.  Feel free to do anything else
 *  you wish with it.
 */


char xvt_command_c_sccsid[] = "@(#)command.c	1.3 9/12/93 (UKC)";

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <utmp.h>
#include <errno.h>
#include <string.h>
#include "xvt.h"
#include "token.h"
#include "command.h"
#include "omshell.h"
#include "ttyinit.h"
#include "screen.h"

#ifdef AIX3
#include <sys/select.h>
#endif /* AIX3 */

#define NLMAX	15	/* max number of lines to scroll */

#define KBUFSIZE	256	/* size of keyboard mapping buffer */
#define COM_BUF_SIZE	2048	/* size of buffer used to read from the command */
#define COM_PUSH_MAX	20	/* max number of characters that can be pushed
				   back into the input queue */
#define MP_INTERVAL	500	/* multi-press interval in milliseconds */

/*  Special character returned by get_com_char().
 */
#define GCC_NULL	0x100		/* Input buffer is empty */
#define ESC		033

/*  Flags used to control get_com_char();
 */
#define BUF_ONLY	1
#define GET_XEVENTS	2


/*  Global variables that are set up at the beginning and then not changed
 */
extern Display		*display;
extern Window		vt_win;
extern Window		sb_win;
extern Window		main_win;

int comm_fd = -1;	/* file descriptor connected to the command */
int fd_width;	/* width of file descriptors being used */

static int x_fd;	/* file descriptor of the X server connection */
static int app_cur_keys = 0;/* flag to say cursor keys are in application mode */
static int app_kp_keys = 0;	/* flag to set application keypad keys */
static int sun_function_keys = 0;	/* flag set to use Sun function key mapping */

static unsigned char *send_buf = NULL;	/* characters waiting to be sent to the command */
static unsigned char *send_nxt = NULL;	/* next character to be sent */
static int send_count = 0;	/* number of characters waiting to be sent */

/*  Static variables used to record interesting X events.
 */
/*  Small X event structure used to queue interesting X events that need to
 *  be converted into tokens.
 */
struct xeventst {
	int xe_type;
	int xe_button;
	int xe_state;
	int xe_x;
	int xe_y;
	int xe_width;
	int xe_height;
	int xe_detail;
	unsigned long xe_time;
	Window xe_window;
	Atom xe_property;		/* for selection requests */
	Atom xe_target;
	Window xe_requestor;		/* ditto */
	struct xeventst *xe_next;
	struct xeventst *xe_prev;
};

static struct xeventst *xevent_start = NULL;
static struct xeventst *xevent_last = NULL;		/* start and end of queue */

/*  Variables used for buffered command input.
 */
static unsigned char com_buf[COM_BUF_SIZE];
static unsigned char *com_buf_next, *com_buf_top;
static unsigned char com_stack[COM_PUSH_MAX];	/* stack of pushed back characters */
static unsigned char *com_stack_top;

/*  Thanks to Rob McMullen for the following function key mapping tables
 *  and code.
 */
/*  Structure used to describe the string generated by a function key,
 *  keypad key, etc.
 */
struct keystringst {
	char ks_type;		/* the way  to generate the string (see below) */
	unsigned char ks_value;	/* value used in creating the string */
};

/*  Different values for ks_type which determine how the value is used to
 *  generate the string.
 */
#define KS_TYPE_NONE	(char)0		/* No output */
#define KS_TYPE_CHAR	(char)1		/* as printf("%c",ks_value) */
#define KS_TYPE_XTERM	(char)2		/* as printf("\033[%d",ks_value) */
#define KS_TYPE_SUN	(char)3		/* as printf("\033[%dz",ks_value) */
#define KS_TYPE_APPKEY	(char)4		/* as printf("\033O%c",ks_value) */
#define KS_TYPE_NONAPP	(char)5		/* as printf("\033[%c",ks_value) */
/* Added by cpbs for Debian, 1999/12/7: this is only used for the Delete key */
#define KS_TYPE_VT220	(char)6		/* as printf("\033[%d~",ks_value) */

/*  Structure used to map a keysym to a string.
 */
struct keymapst {
	KeySym km_keysym;
	struct keystringst km_normal;	/* The usual string */
	struct keystringst km_alt;	/* The alternative string */
};


#ifdef __STDC__
static struct xeventst *pop_xevent(void);
static int get_com_char(int);
static void push_com_char(int);
#ifdef DEBUG
static void show_token_args(struct tokenst *);
static void show_hex_token_args(struct tokenst *);
#endif /* DEBUG */
#else /* __STDC__ */
static struct xeventst *pop_xevent();
static int get_com_char();
static void push_com_char();
#ifdef DEBUG
static void show_token_args();
static void show_hex_token_args();
#endif /* DEBUG */
#endif /* __STDC__ */


static struct xeventst *
pop_xevent()
{
	struct xeventst *xe;

	if (xevent_last == NULL)
		return(NULL);

	xe = xevent_last;
	xevent_last = xe->xe_prev;
	if (xevent_last != NULL)
		xevent_last->xe_next = NULL;
	else
		xevent_start = NULL;
	return(xe);
}

/*  Initialise the command connection.  This should be called after the X
 *  server connection is established.
 */
void
init_command(command,argv)
char *command;
char **argv;
{

	if ((comm_fd = run_command(command,argv)) < 0) {
		perror("Quitting");
		quit(1);
	}
	com_buf_next = com_buf_top = com_buf;
	com_stack_top = com_stack;
}

/*  Set the current cursor keys mode.
 */
void
set_cur_keys(mode)
int mode;
{
	app_cur_keys = (mode == HIGH);
}

/*  Set the current keypad keys mode.
 */
void
set_kp_keys(mode)
int mode;
{
	app_kp_keys = (mode == HIGH);
}

/*  Enable or disable the use of Sun function key mapping.
 */
void
set_sun_function_keys(value)
int value;
{
	sun_function_keys = value;
}


/*  Return the next input character after first passing any keyboard input
 *  to the command.  If flags & BUF_ONLY is true then only buffered characters are
 *  returned and once the buffer is empty the special value GCC_NULL is
 *  returned.  If flags and GET_XEVENTS is true then GCC_NULL is returned
 *  when an X event arrives.
 */
static int
get_com_char(flags)
int flags;
{
	fd_set in_fdset, out_fdset;
	/* unsigned char *letra; */
	char *letra;
	int count;
	unsigned char mask = 1 ? 0xff : 0x7f;
	extern int errno;

	if (com_stack_top > com_stack)
		return(*--com_stack_top);

	if (com_buf_next < com_buf_top)
		return(*com_buf_next++ & mask);
	else if (flags & BUF_ONLY)
		return(GCC_NULL);


	int k; /* for sdl */
	int count2;
	for (;;) {
		FD_ZERO(&in_fdset);
			if (FD_ISSET(x_fd,&in_fdset))
				/*  If we get to this point something is wrong
				 *  because there is X input available but no
				 *  events.  Exit the program to avoid looping
				 *  forever.
				 */
				quit(0);
			FD_SET(comm_fd,&in_fdset);
			FD_SET(x_fd,&in_fdset);
			FD_ZERO(&out_fdset);
			if (send_count > 0)
				FD_SET(comm_fd,&out_fdset);

			if (FD_ISSET(comm_fd,&out_fdset)) {
				count = send_count < 100 ? send_count : 100;
				count = write(comm_fd,send_nxt,count);
				if (count < 0) {
					perror("failed to write to command");
					quit(-1);
				}
				send_count -= count;
				send_nxt += count;
			}

			if (FD_ISSET(comm_fd,&in_fdset)) {
			}



			k = omshell_check_ts();
			if (k<100)
				omshell_keypressed(k);
			else if (k>100) {
				letra = omshell_keyreleased();
					if (((*letra) == 201) || ((*letra) == 202))
						return (*letra);
					else if ((*letra) != '\0')
						count2 = write(comm_fd,letra,1);
			}


		if (FD_ISSET(comm_fd,&in_fdset))
			break;

	}

	count = read(comm_fd,com_buf,COM_BUF_SIZE);
	if (count <= 0) {
		if (errno == EWOULDBLOCK) {
			return(GCC_NULL);
		} else {
			return(EOF);
		}
	}
	com_buf_next = com_buf;
	com_buf_top = com_buf + count;
	return(*com_buf_next++ & mask);
}

/*  Push an input character back into the input queue.
 */
static void
push_com_char(c)
int c;
{
	if (com_stack_top < com_stack + COM_PUSH_MAX)
		*com_stack_top++ = c;
}

/*  Send count characters directly to the command.
 */
void
send_string(buf,count)
unsigned char *buf;
int count;
{
	unsigned char *s;
	register unsigned char *s1, *s2;
	register int i;

	if (count == 0)
		return;

	if (send_count == 0) {
		if (send_buf != NULL) {
			free(send_buf);
			send_buf = NULL;
		}
		send_buf = (unsigned char *)cmalloc(count);
		s2 = send_buf;
		s1 = buf;
		for (i = 0; i < count; i++, s1++, s2++)
			*s2 = *s1;
		send_nxt = send_buf;
		send_count = count;
	} else {
		s = (unsigned char *)cmalloc(send_count + count);
		memcpy(s,send_nxt,send_count);
		s2 = s + send_count;
		s1 = buf;
		for (i = 0; i < count; i++, s1++, s2++)
			*s2 = *s1;
		free(send_buf);
		send_buf = send_nxt = s;
		send_count += count;
	}
}

/*  Send printf formatted output to the command.  Only used for small ammounts
 *  of data.
 */
/*VARARGS1*/
void
#ifdef __STDC__
cprintf(char *fmt,...)
{
	va_list args;
	static unsigned char buf[1024];

	va_start(args,fmt);
#else
cprintf(va_alist)
va_dcl
{
	char *fmt;
	va_list args;
	static unsigned char buf[1024];

	va_start(args);
	fmt = va_arg(args,char *);
#endif

	vsprintf((char *)buf,fmt,args);
	va_end(args);
	send_string(buf,strlen((char *)buf));
}

/*  Return an input token
 */
void
get_token(tk)
struct tokenst *tk;
{
	int c, i, n;
	struct xeventst *xe;

	tk->tk_private = 0;
	tk->tk_type = TK_NULL;

	if ((xe = pop_xevent()) != NULL) {
		switch (xe->xe_type) {
		    case EnterNotify :
			tk->tk_type = TK_ENTRY;
			tk->tk_arg[0] = 1;
			tk->tk_nargs = 1;
			break;
		    case LeaveNotify :
			tk->tk_type = TK_ENTRY;
			tk->tk_arg[0] = 0;
			tk->tk_nargs = 1;
			break;
		    case FocusIn :
			tk->tk_type = TK_FOCUS;
			tk->tk_arg[0] = 1;
			tk->tk_arg[1] = xe->xe_detail;
			tk->tk_nargs = 2;
			break;
		    case FocusOut :
			tk->tk_type = TK_FOCUS;
			tk->tk_arg[0] = 0;
			tk->tk_arg[1] = xe->xe_detail;
			tk->tk_nargs = 2;
			break;
		    case Expose :
			tk->tk_type = TK_EXPOSE;
			tk->tk_arg[0] = xe->xe_x;
			tk->tk_arg[1] = xe->xe_y;
			tk->tk_arg[2] = xe->xe_width;
			tk->tk_arg[3] = xe->xe_height;
			tk->tk_nargs = 4;
			break;
		    case ConfigureNotify :
			tk->tk_type = TK_RESIZE;
			tk->tk_nargs = 0;
			break;
		    case SelectionClear :
			tk->tk_type = TK_SELCLEAR;
			tk->tk_arg[0] = xe->xe_time;
			tk->tk_nargs = 1;
			break;
		    case SelectionNotify :
			tk->tk_type = TK_SELNOTIFY;
			tk->tk_arg[0] = xe->xe_time;
			tk->tk_arg[1] = xe->xe_requestor;
			tk->tk_arg[2] = xe->xe_property;
			tk->tk_nargs = 3;
			break;
		    case SelectionRequest :
			tk->tk_type = TK_SELREQUEST;
			tk->tk_arg[0] = xe->xe_time;
			tk->tk_arg[1] = xe->xe_requestor;
			tk->tk_arg[2] = xe->xe_target;
			tk->tk_arg[3] = xe->xe_property;
			tk->tk_nargs = 4;
			break;
		    case ButtonPress :
			break;
		    case ButtonRelease :
			break;
		    case MotionNotify :
			break;
				
		}
		free((void *)xe);
		return;
	}
	if ((c = get_com_char(GET_XEVENTS)) == GCC_NULL) {
		tk->tk_type = TK_NULL;
		return;
	}
	/* for openmoko */
	if (c == 201) {
		tk->tk_type = TK_SBDOWN;
		tk->tk_arg[0] = 150;
		tk->tk_nargs = 1;
		return;
	} else if (c == 202) {
		tk->tk_type = TK_SBUP;
		tk->tk_arg[0] = 150;
		tk->tk_nargs = 1;
		return;
	} 
	/* end for openmoko */

	if (c == EOF) {
		tk->tk_type = TK_EOF;
		return;
	}
	if (is_string_char(c)) {
		i = 0;
		tk->tk_nlcount = 0;
		do {
			tk->tk_string[i++] = c;
			c = get_com_char(1);
			if (c == '\n' && ++tk->tk_nlcount >= NLMAX) {
				tk->tk_nlcount--;
				break;
			}
		} while (is_string_char(c) && i < TKS_MAX);
		tk->tk_length = i;
		tk->tk_string[i] = 0;
		tk->tk_type = TK_STRING;
		if (c != GCC_NULL)
			push_com_char(c);
	} else if (c == ESC) {
		c = get_com_char(0);
		if (c == '[') {
			c = get_com_char(0);
			if (c >= '<' && c <= '?') {
				tk->tk_private = c;
				c = get_com_char(0);
			}

			/*  read any numerical arguments
			 */
			i = 0;
			do {
				n = 0;
				while (c >= '0' && c <= '9') {
					n = n * 10 + c - '0';
					c = get_com_char(0);
				}
				if (i < TK_MAX_ARGS)
					tk->tk_arg[i++] = n;
				if (c == ESC)
					push_com_char(c);
				if (c < ' ')
					return;
				if (c < '@')
					c = get_com_char(0);
			} while (c < '@' && c >= ' ');
			if (c == ESC)
				push_com_char(c);
			if (c < ' ')
				return;
			tk->tk_nargs = i;
			tk->tk_type = c;
		} else if (c == ']') {
			c = get_com_char(0);
			n = 0;
			while (c >= '0' && c <= '9') {
				n = n * 10 + c - '0';
				c = get_com_char(0);
			}
			tk->tk_arg[0] = n;
			tk->tk_nargs = 1;
			c = get_com_char(0);
			i = 0;
			while ((c & 0177) >= ' ' && i < TKS_MAX) {
				if (c >= ' ')
					tk->tk_string[i++] = c;
				c = get_com_char(0);
			}
			tk->tk_length = i;
			tk->tk_string[i] = 0;
			tk->tk_type = TK_TXTPAR;
		} else if (c == '#' || c == '(' || c == ')') {
			tk->tk_type = c;
			c = get_com_char(0);
			tk->tk_arg[0] = c;
			tk->tk_nargs = 1;
		} else if (c == '7' || c == '8' || c == '=' || c == '>') {
			tk->tk_type = c;
			tk->tk_nargs = 0;
		} else {
			switch (c) {
			    case 'D' :
				tk->tk_type = TK_IND;
				break;
			    case 'E' :
				tk->tk_type = TK_NEL;
				break;
			    case 'H' :
				tk->tk_type = TK_HTS;
				break;
			    case 'M' :
				tk->tk_type = TK_RI;
				break;
			    case 'N' :
				tk->tk_type = TK_SS2;
				break;
			    case 'O' :
				tk->tk_type = TK_SS3;
				break;
			    case 'Z' :
				tk->tk_type = TK_DECID;
				break;
			    default :
				return;
			}
		}
	} else {
		tk->tk_type = TK_CHAR;
		tk->tk_char = c;
	}
}

#ifdef DEBUG
/*  Print out a token's numerical arguments. Just used by show_token()
 */
static void
show_token_args(tk)
struct tokenst *tk;
{
	int i;

	for (i = 0; i < tk->tk_nargs; i++) {
		if (i == 0)
			printf(" (%d",tk->tk_arg[i]);
		else
			printf(",%d",tk->tk_arg[i]);
	}
	if (tk->tk_nargs > 0)
		printf(")");
	if (tk->tk_private !=0)
		putchar(tk->tk_private);
}

/*  Print out a token's numerical arguments in hex. Just used by show_token()
 */
static void
show_hex_token_args(tk)
struct tokenst *tk;
{
	int i;

	for (i = 0; i < tk->tk_nargs; i++) {
		if (i == 0)
			printf(" (0x%x",tk->tk_arg[i]);
		else
			printf(",0x%x",tk->tk_arg[i]);
	}
	if (tk->tk_nargs > 0)
		printf(")");
	if (tk->tk_private !=0)
		putchar(tk->tk_private);
}

/*  Print out the contents of an input token - used for debugging.
 */
void
show_token(tk)
struct tokenst *tk;
{

	/*  Screen out token types that are not currently of interest.
	 */
	switch (tk->tk_type) {
		case TK_SELDRAG :
			return;
	}

	switch (tk->tk_type) {
		case TK_STRING :
			printf("token(TK_STRING)");
			printf(" \"%s\"",tk->tk_string);
			break;
		case TK_TXTPAR :
			printf("token(TK_TXTPAR)");
			printf(" (%d) \"%s\"",tk->tk_arg[0],tk->tk_string);
			break;
		case TK_CHAR :
			printf("token(TK_CHAR)");
			printf(" <%o>",tk->tk_char);
			break;
		case TK_EOF :
			printf("token(TK_EOF)");
			show_token_args(tk);
			break;
		case TK_FOCUS :
			printf("token(TK_FOCUS)");
			printf(" <%d>",tk->tk_region);
			show_token_args(tk);
			break;
		case TK_ENTRY :
			printf("token(TK_ENTRY)");
			printf(" <%d>",tk->tk_region);
			show_token_args(tk);
			break;
		case TK_SBSWITCH :
			printf("token(TK_SBSWITCH)");
			show_token_args(tk);
			break;
		case TK_SBGOTO :
			printf("token(TK_SBGOTO)");
			show_token_args(tk);
			break;
		case TK_SBUP :
			printf("token(TK_SBUP)");
			show_token_args(tk);
			break;
		case TK_SBDOWN :
			printf("token(TK_SBDOWN)");
			show_token_args(tk);
			break;
		case TK_EXPOSE :
			printf("token(TK_EXPOSE)");
			printf("(%d)",tk->tk_region);
			show_token_args(tk);
			break;
		case TK_RESIZE :
			printf("token(TK_RESIZE)");
			show_token_args(tk);
			break;
		case TK_SELSTART :
			printf("token(TK_SELSTART)");
			show_token_args(tk);
			break;
		case TK_SELEXTND :
			printf("token(TK_SELEXTND)");
			show_token_args(tk);
			break;
		case TK_SELDRAG :
			printf("token(TK_SELDRAG)");
			show_token_args(tk);
			break;
		case TK_SELINSRT :
			printf("token(TK_SELINSRT)");
			show_token_args(tk);
			break;
		case TK_SELECT :
			printf("token(TK_SELECT)");
			show_token_args(tk);
			break;
		case TK_SELWORD :
			printf("token(TK_SELWORD)");
			show_token_args(tk);
			break;
		case TK_SELLINE :
			printf("token(TK_SELLINE)");
			show_token_args(tk);
			break;
		case TK_SELCLEAR :
			printf("token(TK_SELCLEAR)");
			show_token_args(tk);
			break;
		case TK_SELNOTIFY :
			printf("token(TK_SELNOTIFY)");
			show_hex_token_args(tk);
			break;
		case TK_SELREQUEST :
			printf("token(TK_SELREQUEST)");
			show_hex_token_args(tk);
			break;
		case TK_CUU :
			printf("token(TK_CUU)");
			show_token_args(tk);
			break;
		case TK_CUD :
			printf("token(TK_CUD)");
			show_token_args(tk);
			break;
		case TK_CUF :
			printf("token(TK_CUF)");
			show_token_args(tk);
			break;
		case TK_CUB :
			printf("token(TK_CUB)");
			show_token_args(tk);
			break;
		case TK_CUP :
			printf("token(TK_CUP)");
			show_token_args(tk);
			break;
		case TK_ED :
			printf("token(TK_ED)");
			show_token_args(tk);
			break;
		case TK_EL :
			printf("token(TK_EL)");
			show_token_args(tk);
			break;
		case TK_IL :
			printf("token(TK_IL)");
			show_token_args(tk);
			break;
		case TK_DL :
			printf("token(TK_DL)");
			show_token_args(tk);
			break;
		case TK_DCH :
			printf("token(TK_DCH)");
			show_token_args(tk);
			break;
		case TK_ICH :
			printf("token(TK_ICH)");
			show_token_args(tk);
			break;
		case TK_DA :
			printf("token(TK_DA)");
			show_token_args(tk);
			break;
		case TK_HVP :
			printf("token(TK_HVP)");
			show_token_args(tk);
			break;
		case TK_TBC :
			printf("token(TK_TBC)");
			show_token_args(tk);
			break;
		case TK_SET :
			printf("token(TK_SET)");
			show_token_args(tk);
			break;
		case TK_RESET :
			printf("token(TK_RESET)");
			show_token_args(tk);
			break;
		case TK_SGR :
			printf("token(TK_SGR)");
			show_token_args(tk);
			break;
		case TK_DSR :
			printf("token(TK_DSR)");
			show_token_args(tk);
			break;
		case TK_DECSTBM :
			printf("token(TK_DECSTBM)");
			show_token_args(tk);
			break;
		case TK_DECSWH :
			printf("token(TK_DECSWH)");
			show_token_args(tk);
			break;
		case TK_SCS0 :
			printf("token(TK_SCS0)");
			show_token_args(tk);
			break;
		case TK_SCS1 :
			printf("token(TK_SCS1)");
			show_token_args(tk);
			break;
		case TK_DECSC :
			printf("token(TK_DECSC)");
			show_token_args(tk);
			break;
		case TK_DECRC :
			printf("token(TK_DECRC)");
			show_token_args(tk);
			break;
		case TK_DECPAM :
			printf("token(TK_DECPAM)");
			show_token_args(tk);
			break;
		case TK_DECPNM :
			printf("token(TK_DECPNM)");
			show_token_args(tk);
			break;
		case TK_IND :
			printf("token(TK_IND)");
			show_token_args(tk);
			break;
		case TK_NEL :
			printf("token(TK_NEL)");
			show_token_args(tk);
			break;
		case TK_HTS :
			printf("token(TK_HTS)");
			show_token_args(tk);
			break;
		case TK_RI :
			printf("token(TK_RI)");
			show_token_args(tk);
			break;
		case TK_SS2 :
			printf("token(TK_SS2)");
			show_token_args(tk);
			break;
		case TK_SS3 :
			printf("token(TK_SS3)");
			show_token_args(tk);
			break;
		case TK_DECID :
			printf("token(TK_DECID)");
			show_token_args(tk);
			break;
		case TK_NULL :
			return;
		default :
			printf("unknown token <%o>",tk->tk_type);
			show_token_args(tk);
			break;
	}
	printf("\n");
}
#endif /* DEBUG */
